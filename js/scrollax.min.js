(function (factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
    } else if (typeof exports !== "undefined") {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function ($) {

    function warn(message) {
        if (console && console.warn) {
            console.warn("Scrollax: " + message);
        } else {
            throw "Scrollax: " + message;
        }
    }

    function getViewportMetrics(el) {
        const isWindow = !!("pageYOffset" in el);
        return {
            width: isWindow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : el.offsetWidth,
            height: isWindow ? window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight : el.offsetHeight,
            left: el[isWindow ? "pageXOffset" : "scrollLeft"],
            top: el[isWindow ? "pageYOffset" : "scrollTop"]
        };
    }

    function parseDataAttributes(el) {
        const data = el.data("scrollax");
        return data && eval("({" + data + "})") || {};
    }

    function isWindow(obj) {
        let doc, view;
        return !!(
            obj && typeof obj === "object" &&
            typeof obj.window === "object" &&
            obj.window === obj &&
            obj.setTimeout &&
            obj.alert &&
            (doc = obj.document) &&
            typeof doc === "object" &&
            (view = doc.defaultView || doc.parentWindow) &&
            view === obj
        );
    }

    const transformProps = [
        "translateX", "translateY", "rotate", "rotateX", "rotateY", "rotateZ",
        "skewX", "skewY", "scaleX", "scaleY"
    ];

    const $window = $(window);
    const $body = $(document.body);
    let transformCSS, prefix;

    function Scrollax(frameEl, options, context) {
        const self = this;
        const $frame = frameEl ? $(frameEl).eq(0) : $window;
        const existingInstance = Scrollax.instances.find(inst => inst.frame === frameEl);
        if (!frameEl || existingInstance) {
            warn(existingInstance ? "Scrollax already initialized for this frame!" : "Frame not available!");
            return;
        }

        const settings = $.extend({}, Scrollax.defaults, options);
        let parents = [];
        let elements = [];
        let isHorizontal = !!settings.horizontal;
        let scrollTarget = isWindow(frameEl) ? $body : $frame;
        let initialized = false;
        let events = {};
        let ticking = false;

        function getIndex(input) {
            if (typeof input === "undefined") return -1;
            if (typeof input === "number") return input >= 0 && input < parents.length ? input : -1;
            if (typeof input === "string" || typeof input === "object") return parents.indexOf(input);
            return -1;
        }

        function on(event, handler) {
            if (typeof event === "object") {
                for (const key in event) {
                    if (Object.prototype.hasOwnProperty.call(event, key)) {
                        on(key, event[key]);
                    }
                }
            } else if (typeof handler === "function") {
                const parts = event.split(" ");
                parts.forEach(evt => {
                    events[evt] = events[evt] || [];
                    if (!events[evt].includes(handler)) {
                        events[evt].push(handler);
                    }
                });
            }
            return self;
        }

        function off(event, handler) {
            const parts = event.split(" ");
            parts.forEach(evt => {
                if (typeof handler === "undefined") {
                    events[evt] = [];
                } else {
                    const index = events[evt].indexOf(handler);
                    if (index !== -1) events[evt].splice(index, 1);
                }
            });
            return self;
        }

        function trigger(event, data) {
            if (events[event]) {
                events[event].forEach(callback => callback.call(self, event, data));
            }
        }

        function updateParallax() {
            const viewport = getViewportMetrics(frameEl);

            parents.forEach(item => {
                const parentBox = getElementBox(item.element, frameEl);
                if (parentBox[isHorizontal ? "right" : "bottom"] < 0 || parentBox[isHorizontal ? "left" : "top"] > viewport[isHorizontal ? "width" : "height"]) {
                    return;
                }

                const options = item.options;
                const offset = options.offset || settings.offset || 0;
                let position = parentBox[isHorizontal ? "right" : "bottom"];
                let dimension = parentBox[isHorizontal ? "width" : "height"];
                let progress = (dimension - position + offset) / dimension;

                if (progress < 0) {
                    position = parentBox[isHorizontal ? "left" : "top"];
                    dimension = viewport[isHorizontal ? "width" : "height"];
                    progress = -1 + (dimension - position + offset) / dimension;
                }

                if (progress >= -1 && progress <= 1) {
                    applyParallax(item.parallaxElements, progress, isHorizontal);
                }
            });

            trigger("scroll", viewport);
        }

        function applyParallax(elements, progress, isHorizontal) {
            elements.forEach(el => {
                const $el = $(el.element);
                const properties = el.properties || (isHorizontal ? { translateX: "100%" } : { translateY: "100%" });
                let transformString = "";

                for (const prop in properties) {
                    let value = properties[prop];

                    if (typeof value === "number") {
                        value *= progress;
                    } else if (typeof value === "string") {
                        value = value.replace(/[-+]?\d+(\.\d+)?/g, num => parseFloat(num) * progress);
                    }

                    if (transformProps.includes(prop)) {
                        transformString += `${prop}(${value}) `;
                    } else {
                        if (prop === "opacity") {
                            value = progress < 0 ? 1 + value : 1 - value;
                            value = Math.max(0, Math.min(1, value));
                        }
                        $el.css(prop, value);
                    }
                }

                if (transformString) {
                    $el.css(transformCSS, prefix + transformString.trim());
                }
            });
        }

        function reload() {
            parents = [];
            $frame.find(settings.parentSelector || "[data-scrollax-parent]").each(function () {
                const $parent = $(this);
                const options = parseDataAttributes($parent);
                const parallaxElements = [];

                $parent.find(settings.elementsSelector || "[data-scrollax]").each(function () {
                    const childOptions = parseDataAttributes($(this));
                    childOptions.element = this;
                    parallaxElements.push(childOptions);
                });

                parents.push({ element: this, options, parallaxElements });
            });

            updateParallax();
            trigger("load");
            return self;
        }

        function init() {
            if (initialized) return self;
            reload();
            addEvent(window, "resize", reload);
            addEvent(frameEl, "scroll", updateParallax);
            Scrollax.instances.push(self);
            initialized = true;
            trigger("initialized");
            return self;
        }

        function destroy() {
            removeEvent(window, "resize", reload);
            removeEvent(frameEl, "scroll", updateParallax);
            Scrollax.instances = Scrollax.instances.filter(inst => inst.frame !== frameEl);
            parents = [];
            initialized = false;
            trigger("destroy");
            return self;
        }

        self.frame = frameEl;
        self.options = settings;
        self.parents = parents;
        self.initialized = false;
        self.reload = reload;
        self.scroll = updateParallax;
        self.getIndex = getIndex;
        self.on = on;
        self.off = off;
        self.destroy = destroy;
        self.init = init;
    }

    Scrollax.instances = [];

    function getElementBox(el, frame) {
        const doc = el.ownerDocument || el;
        const docEl = doc.documentElement;
        const win = isWindow(frame) ? frame : doc.defaultView || window;

        const scrollTop = (win.pageYOffset || docEl.scrollTop) - docEl.clientTop;
        const scrollLeft = (win.pageXOffset || docEl.scrollLeft) - docEl.clientLeft;

        let box = {};
        if (el.getBoundingClientRect) {
            box = el.getBoundingClientRect();
            box = {
                ...box,
                width: box.right - box.left,
                height: box.bottom - box.top,
                top: box.top + scrollTop,
                left: box.left + scrollLeft,
                right: box.right + scrollLeft,
                bottom: box.bottom + scrollTop
            };
        }

        return box;
    }

    function addEvent(el, type, handler, options) {
        if (el.addEventListener) {
            el.addEventListener(type, handler, options || false);
        } else {
            el.attachEvent("on" + type, handler);
        }
    }

    function removeEvent(el, type, handler) {
        if (el.removeEventListener) {
            el.removeEventListener(type, handler, false);
        } else {
            el.detachEvent("on" + type, handler);
        }
    }

    function getSupportedTransform() {
        const props = ["", "webkit", "moz", "ms", "o"];
        const el = document.createElement("div");

        for (let i = 0; i < props.length; i++) {
            const prop = props[i] ? props[i] + "Transform" : "transform";
            if (el.style[prop] !== undefined) return prop;
        }

        return null;
    }

    transformCSS = getSupportedTransform();
    prefix = getSupportedTransform("perspective") ? "translateZ(0) " : "";

    Scrollax.defaults = {
        horizontal: false,
        offset: 0,
        parentSelector: null,
        elementsSelector: null,
        performanceTrick: false
    };

    $.fn.Scrollax = function (methodOrOptions, ...args) {
        return this.each(function () {
            let instance = $.data(this, "scrollax");
            if (!$.isPlainObject(methodOrOptions)) {
                if (instance && typeof instance[methodOrOptions] === "function") {
                    instance[methodOrOptions](...args);
                }
            } else if (!instance) {
                $.data(this, "scrollax", new Scrollax(this, methodOrOptions).init());
            }
        });
    };

    $.Scrollax = function (options, context) {
        $window.Scrollax(options, context);
    };

    const styleEl = document.createElement("style");
    styleEl.type = "text/css";
    styleEl.textContent = `
        .scrollax-performance,
        .scrollax-performance *,
        .scrollax-performance *:before,
        .scrollax-performance *:after {
            pointer-events: none !important;
            -webkit-animation-play-state: paused !important;
            animation-play-state: paused !important;
        }
    `;
    (document.head || document.getElementsByTagName("head")[0]).appendChild(styleEl);

    return Scrollax;
}));
